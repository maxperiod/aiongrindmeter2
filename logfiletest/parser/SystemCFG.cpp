#include <fstream>
#include <sstream>
#include <string>

#include "SystemCFG.h"

using namespace std;

void SystemCFG::readCFG(const string& filename, bool encrypted){
	entries.clear();
	ifstream stream;
	stream.open(filename);
	
	if (stream.good()) CFGReadSuccess = true;
	else CFGReadSuccess = false;

	int lineNumber = 0;
	while(stream.is_open()){
		string s;
		getline(stream, s);
		if (stream.eof()) break;

		string inverse(s);

		if (encrypted){
			if (s.size() > 0 && ~s[0] >= 'a' && ~s[0] <= 'z'){
				for (int i = 0; i < s.size(); i ++){			
					inverse[i] = ~(s[i]);					
				}
			}
		}

		if (s.size() > 0){
			if (inverse[0] >= 'a' && inverse[0] <= 'z'){

				int endOfAttribute = 0;
				int valueBegin = 0;
				int valueEnd = 0;

				for (int i = 0; i < inverse.length(); i ++){
			
					if (inverse[i] == ' ' && inverse[i+1] == '=' && inverse[i+2] == ' '){
						endOfAttribute = i;
						i += 2;
					}
					else if (inverse[i] == '\"'){
						if (valueBegin == 0) valueBegin = i + 1;
						else if (valueEnd == 0) valueEnd = i;
					}
				}
				string attribute(inverse, 0, endOfAttribute);
				string value(inverse, valueBegin, valueEnd - valueBegin);
				entries.insert(pair<string, string>(attribute, value));
			}
		}
	}
	stream.close();
}

bool SystemCFG::writeCFG(const string& filename, bool encrypted){
	bool success = false;
	if (!CFGReadSuccess) return success;

	ostringstream stringstream;
	ofstream stream;
	stream.open(filename);
	if(stream.is_open()){
		stream << "-- [System-Configuration Ver1.0]" << endl;
		stream << "-- Attention: This file is generated by the system, do not modify! Editing is not recommended! " << endl;
		stream << endl;

		for (CFGmap::iterator iter = entries.begin(); iter != entries.end(); iter ++){
			
			stringstream << iter->first << " = \"" << iter->second << "\"" << endl;
		}

		string output = stringstream.str();
		string encryptedOutput(output);

		if (encrypted){
			if (output.size() > 0){
				for (int i = 0; i < output.size(); i ++){			
					if (output[i] != '\n'){
						encryptedOutput[i] = ~(output[i]);
					}
					else {
						encryptedOutput[i] = output[i];
					}
				}
			}
		}
		stream << encryptedOutput << endl;			
		success = true;
	}

	stream.close();
	return success;
}

string SystemCFG::getProperty(const string& attribute) const{
	if (entries.count(attribute) == 1) return entries.at(attribute);
	return "";
}

void SystemCFG::setProperty(const string& attribute, const string& value){
	entries[attribute] = value;
}

void SystemCFG::removeProperty(const string& attribute){
	entries.erase(attribute);
}

bool caseInsensitiveStringCompare::operator()(const string& lhs, const string& rhs) const{
	int lhsLength = lhs.length();
	int rhsLength = rhs.length();

	const char* left = lhs.c_str();
	const char* right = rhs.c_str();

	for (int i = 0; i < lhsLength && i < rhsLength; i ++){
		char lChar = left[i];
		char rChar = right[i];
		if (lChar >= 'A' && lChar <= 'Z') lChar += 32;
		if (rChar >= 'A' && rChar <= 'Z') rChar += 32;
		if (lChar < rChar) return true;
		else if (lChar > rChar) return false;
		else if (i + 1 >= lhsLength && i + 1 < rhsLength) return true;
		
	}
	return false;
}